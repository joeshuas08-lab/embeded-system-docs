#ESD check （黑屏判定）:

##根据IC手册上ESD寄存器的addr,但是实际上include/video/mipi_display.h中已经定义好addr是0x0A;
    0x0A (Get Power Mode): 這是 MIPI DCS 標準協議中定義的一個通用寄存器，
    理論上大部分符合標準的面板都應該支持。它返回面板當前的電源狀態（如：是否在 Sleep 模式、顯示是否開啟等）。
##调用drm_mipi_dsi.c中定义的mipi_dsi_dcs_get_power_mode，读取（屏端IC的）ESD寄存器的值；
###调用
    +	err = mipi_dsi_dcs_get_power_mode(dsi, &value);
###定义
    ####mipi_dsi_dcs_get_power_mode() - query the display module's current power mode
    ####dsi: DSI peripheral device
    ####mode: return location for the current power mode
    ####Return: 0 on success or a negative error code on failure.
    int mipi_dsi_dcs_get_power_mode(struct mipi_dsi_device *dsi, u8 *mode)
    {
	ssize_t err;

	err = mipi_dsi_dcs_read(dsi, MIPI_DCS_GET_POWER_MODE, mode,
				sizeof(*mode));
	if (err <= 0) {
		if (err == 0)
			err = -ENODATA;

		return err;
	}

	return 0;
    }
    EXPORT_SYMBOL(mipi_dsi_dcs_get_power_mode);

##对比IC手册上ESD寄存器正常的值，决定是否要执行ESD reset；
    bool normal = (esd_check_value_read(p) == 0x9c) ? true : false;
###通过屏端IC手册获取正常值
    image.png
###通过内核api读取并打印查看
    #define DEBUG
    pr_debug("mipi debug read esd normal val: 0x%x\n",esd_check_value_read(p));

##同时需要把drm框架代码的返回超时给限制到一定时长
    drivers/gpu/drm/rockchip/dw-mipi-dsi2-rockchip.c：
    dsi_write(dsi2, DSI2_PHY_MAX_RD_T_MAN_CFG, PHY_MAX_RD_TIME(100));
    超时无返回也判定为黑屏


#ESD reset （重新初始化）:
##1. 軟體層面的狀態強制（DRM 框架）
    在 esd_mipi_reset 函數中，最核心的代码是：
    conn->force = DRM_FORCE_OFF;  // 第一步：強制關閉
    ... ... ...  ... ... ...
    +	msleep(1000);                 // 等待 1 秒
    +	conn->force = DRM_FORCE_ON;   // 第二步：強制開啟
##2. 硬體層面的重新初始化（Panel Driver）
    *当上述 DRM_FORCE_ON 执行时，panel-simple.c 會重新执行一遍完整的面板点亮序列（重新初始化）*

    -拉低 Reset Pin: 給面板 IC 一個硬體復位訊號（如果電路有連 Reset 引腳）。
    -重新上電: 透過 GPIO 或 PMIC 重新給 VCC/VGH/VGL 供電。
    -發送初始化命令 (Init Sequence): 重新把那幾十條甚至上百條的 MIPI 寄存器配置命令（DCS commands）發給面板。 這一步最關鍵，因為 ESD 導致的寄存器混亂或邏輯死鎖，在硬體復位和重新載入配置後會徹底消失。


#時序與計數器的重置:
    為了保證恢復過程不會死循環，代碼做了細節處理：
    停止檢查: 在重置期間，調用 cancel_delayed_work_sync(&p->esd_check_dw)，防止在重置還沒完成時又觸發新的 ESD 檢測。
    歸零計數: 重置完成後，將 p->esd_num = 0，讓系統從乾淨的狀態重新開始監控。

